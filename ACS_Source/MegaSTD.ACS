#library "MEGASTD"
#include "zcommon.acs"
#include "8BDMLIB.ACS"

#import "a_Core.acs"
#import "a_Loadout.acs"
#import "db_Loadout.acs"
#import "a_Properties.acs"
#import "db_Properties.acs"
#import "A_Pain.acs"

//#region -=- Hit Event -=-
#region -=- Hit Event -=-
script "MSTD_HitEvents" (int type, int arg1, int arg2) EVENT
{
if(CheckForIgnore(arg2)){Terminate;}

int Damage = arg1;
str PainType = arg2;
int SourceTID;
int VictimTID = ActivatorTID();
int VictimHP = GetActorProperty(0,APROP_HEALTH);
int VictimHPPer = GetHealthPercent(0,0,0);

bool CritHit,Assassin,FireCrit,PoisonCrit,FrostBiteCrit,Guts,Determined,Marksman;
int DB_Determined,DB_Guts,DB_Marksman;
if(type == 11) //GAMEEVENT_ACTOR_DAMAGED 
{

//===============|Check for damage properties on the opposing player|===============
SetActivator(0, AAPTR_DAMAGE_SOURCE);
SourceTID = ActivatorTID();

//==Mastery Damage Bonus ==
//Also to avoid boosting self damage
if(IsPointerEqual(AAPTR_DAMAGE_TARGET,AAPTR_DAMAGE_SOURCE) == False){if(CheckMasteryDamage(arg2)){Damage += DamageModify(Damage,P_MASTERYDAMAGE);}}

//==Assassin Bonus==
if(CheckForCrit(arg2)){CritHit = true;}
if(VictimHPPer >= 100 && CheckProp(MasterProPList[19][PROP_NAME])){Assassin = true;}


//===|FrostBite Hitstun|===
//if(CheckForFrostBiteHitstun(arg2)){GiveActorInventory(VictimTID,"FrostbiteHitstun",1);}

//===|Guts Boost|===
if(CheckForGutsy()){Guts = true;}

//===|Determined Boost|===
if(CheckForDetermined(arg2))
	{
	Determined = true;
	DB_Determined = MassimoDamageRamp(0,DamageModify(Damage,P_DETERMINED),-1);
	}
//===|Marksman Boost|===
if(CheckForMarksman(arg2,VictimTID))
	{
	Marksman = true;
	DB_Marksman = ValueMap(xyzDistance(0, VictimTID),MARKSMANSTART,MARKSMANEND,DamageModify(Damage,P_MARKSMANLOW),DamageModify(Damage,P_MARKSMANHIGH));
	DB_Marksman = RoundToNth(DB_Marksman,5);
	if(DB_Marksman > DamageModify(Damage,P_MARKSMANHIGH)){DB_Marksman = DamageModify(Damage,P_MARKSMANHIGH);}
	}
//Reduce harm from blast weapons on yourself
if(IsPointerEqual(AAPTR_DAMAGE_TARGET,AAPTR_DAMAGE_SOURCE) == true){if(CheckForSelfBlastGuard(arg2)){Damage = DamageModify(Damage,0.5);}}

//====|Heater/Refrigerate|======
if(CheckForHeater(arg2)){GiveActorInventory(VictimTID,"BurnStatusFastBuild",1);}
if(CheckForREfrigerate(arg2)){GiveActorInventory(VictimTID,"FrostbiteStatusFastBuild",1);}

//===============|Check for damage properties on the recieving player|===============
SetActivator(0, AAPTR_DAMAGE_TARGET);
//==Elemental Resistance modifier ==
if(CheckForResistance(arg2)){Damage = DamageModify(Damage,P_RESISTANCE);}

//==|Elemental Guard modifier|==
if(CheckForElementalGuard(arg2)){Damage = DamageModify(Damage,P_ELMGUARD);}

//==Blade Parrymodifier ==
if(CheckForBladeParry(arg2)){Damage = DamageModify(Damage,0.6);}

if(CheckInventory("UndershirtFlag")&& Damage > GetActorProperty(0,APROP_HEALTH))
	{
	if(!CheckForElement(arg2,ELM_BREAK))
		{
		Damage = GetActorProperty(0,APROP_HEALTH)-1;
		GiveInventory("TacticalRollEvasion_On",1);
		TakeInventory("UndershirtFlag",99);
		localAmbientSound("Body/ArmorPain",127);
		}
	}


//===|conditional status crits|====
if(CheckForFireCrit(arg2)){FireCrit = true; }
if(CheckForPoisonCrit(arg2)){PoisonCrit = true; if(CheckProp(MasterProPList[19][PROP_NAME])){CritHit = true;}}
if(CheckForFrostbiteCrit(arg2)){FrostBiteCrit = true; }

//===============|End Damage Calculations|===============
if(FireCrit){Damage = DamageModify(Damage,P_CRIT);Giveinventory("CritEffectSpawner",1);}
if(PoisonCrit){Damage = DamageModify(Damage,P_CRIT);Giveinventory("CritEffectSpawner",1);}
if(FrostBiteCrit){Damage = DamageModify(Damage,P_CRIT);Giveinventory("CritEffectSpawner",1);}
if(Assassin)
	{Damage += DamageModify(Damage,P_ASSASSIN);
	if(!CritHit){Giveinventory("CritEffectSpawner",1);}
	}
	//{if(PoisonCrit || FireCrit || FrostBiteCrit || CritHit){Damage += DamageModify(Damage,0.2);}}

if(Determined){Damage += DB_Determined;}
if(Guts){Damage += DamageModify(Damage,P_GUTSY);}
if(Marksman){Damage += DB_Marksman;}
//Poison damage is no longer fatal
if(arg2 == "PoisonDOT"){ if(Damage>=VictimHP){Damage = VictimHP-1;}}

//Stopped chharacters are freed once they take 100 damage, however the following won't
//increment this count.
if(!CheckForDontStop(arg2)){TakeInventory("StopCount",Damage);} 

//===============|Post Calculation Passives|===============

//==Fireman Class Passive==
SetActivator(0, AAPTR_DAMAGE_SOURCE);
if(CheckInventory("IsFireman") 
	&& CheckForElement(arg2,ELM_FIRE) 
	&& IsPointerEqual(AAPTR_DAMAGE_TARGET,AAPTR_DAMAGE_SOURCE) == False)
	{GiveInventory("FiremanHeat",arg1*0.5>>16);}
SetActivator(0, AAPTR_DAMAGE_TARGET);

//==Quickman Class Passive==
SetActivator(0, AAPTR_DAMAGE_SOURCE);
if(CheckInventory("IsQuickMan")){GiveInventory("AtomicSpeedResource",(arg1*0.3>>16)+1);GiveInventory("AtomicSpeedUp",1);}
SetActivator(0, AAPTR_DAMAGE_TARGET);

if(Damage>0){TakeInventory("HealRampPower",9);GiveInventory("HealRampPower",1);}
if(GetCvar("MSTD_DDLoaded")){ACS_NamedExecuteAlways("DamageNumbers_Trigger_11",0,type,Damage,SourceTID);}
SetResultValue(Damage);

//==Speedrunner==
//if(CheckSpeedrunnerLoss()){TakeInventory("PowerSpeedRunner",9); LocalAmbientSound("support/StatDown",127);}
}
}

Function int DamageModify(int DMG, int Mult)
{
DMG = DMG<<16;
Mult = Mult+0.0001;
int output = FixedMul(DMG,Mult)>>16;

return output;
}

Function int RoundToNth (int Input, int Nth)
{
int output = (Input/Nth)*Nth;
//Input = Input>>16;
//Nth = Nth>>16;
//int output = FixedMul(Round(FixedDiv(Input,Nth)),Nth);
return output;
}

//Confirms if Trills DamageDisplay is loaded in

Script "TrillDDCheck" OPEN
{
SpawnForced("DM_DamageDone",0,0,0,564,0);
if (ThingCount(T_NONE,564))
	{
	Thing_Remove(564);
	SetCvar("MSTD_DDLoaded",true);
	}
else{SetCvar("MSTD_DDLoaded",false);}

}

#endregion
//#endregion

//#region -=- EntiTID -=-
#region -=- EntiTID -=-

#LIBDEFINE EntityTID 480000
#LIBDEFINE ENTITY_CAP 10 //for masterscrub, to reduce the loops
Script "GiveEntiTID" (Int EntityID)
{
/*
I don't think puns make for good programming practices but why not? hopefully I won't pay for this

anyways, this is for entities that you are only allowed one of per person, this gives them a TID
formatted in the following way:

EntiTID Tag | Player Number | Entity ID
48|00|00
*/
int OwnerTID = ACS_NamedExecuteWithResult("core_gettarget");
if(OwnerTID < 1000){Terminate;}

Int P = (OwnerTID-1000)*100;
int ETID = EntityTID+P+EntityID;

/*
Now, let's kill any actor that already has this ETID
*/

if (ThingCount(T_NONE,ETID)){Thing_Remove(ETID); /*ACS_NamedExecuteAlways("Client_Thing_Remove",0,ETID);*/}
Thing_ChangeTID(0,EntityTID+P+EntityID);
}

#endregion
//#endregion

//#region -=- Check EntiTID -=-
#region -=- Check EntiTID -=-


Script "CheckEntiTID" (int Pointer, Int EntityID)
{

	if(Pointer!=0){SetActivator(0,Pointer);}

Int P = (ActivatorTID()-1000)*100;
int ETID = EntityTID+P+EntityID;

bool Output = false;

if (ThingCount(T_NONE,ETID)){Output = true;}
SetResultValue(Output);

}

#endregion
//#endregion

//#region -=- Multi EntiTID -=-
#region -=- Multi EntiTID -=-

#LIBDEFINE M_ENTITYTID 4900000
#LIBDEFINE M_ENTITY_CAP 6 //for masterscrub, to reduce the loops
int M_EntityRecord[64];
Script "GiveM_EntiTID" (Int EntityID, int EntityCap)
{
/*
This one allows for multiple entities to be spawned but only up to 9. and if a new one is spawned beyond the cap, the old one get's replaced

EntiTID Tag | Player Number | Entity ID | Entity count
49|00|00|0
*/

int OwnerTID = ACS_NamedExecuteWithResult("core_gettarget");
Int P = (OwnerTID-1000)*1000;
int M_ETID = M_ENTITYTID+(P)+(EntityID*100);
int EntityNum;
bool SpawnComplete;

while(!SpawnComplete)
	{
		if(EntityNum >= EntityCap)
			{
				Thing_Remove(M_ETID);
				//ACS_NamedExecuteAlways("Client_Thing_Remove",0,M_ETID);
				for(int i = 1; i < EntityCap; i++)
				{
					Thing_ChangeTID(M_ETID+i,M_ETID+i-1);
					//ACS_NamedExecuteAlways("Client_Thing_ChangeTID",0,M_ETID+i,M_ETID+i-1);
				}
				EntityNum = 0;
			}
		if(ThingCount(T_NONE,M_ETID+EntityNum)){EntityNum++;}
		else{SpawnComplete = true;}

	}
Thing_ChangeTID(0,M_ETID+EntityNum);
}
//#endregion

//#region -=- Radius Give -=-
#region -=- Radius Give -=-

#DEFINE RG_SELF 1
#DEFINE RG_TEAM 2
#DEFINE RG_ENEMY 4
#DEFINE RG_LOS 8

script "STD_RadiusGive" (int GiveID, int GiveRadius, int GiveType)
{ 
int Target_TID;
int Target_Distance;
int FiringPlayer;
int PlayersTeam;
int TeamGame = ACS_ExecuteWithResult(975, 1);
str GivePackage;
Bool GiveClearance;

//GiveType works like a bitwise flag
If(ActivatorTID() <= 999)
	{
	//log(s:"an Actor");
	FiringPlayer= ACS_NamedExecuteWithResult("core_gettarget"); //Returns the target of the activator
	}
Else If(ActivatorTID() >= EntityTID && ActivatorTID() <= (EntityTID+6499))
	{
	//log(s:"an EntiTID");
	FiringPlayer= ACS_NamedExecuteWithResult("core_gettarget"); //Actor is a player spawed entity, Returns the target of the activator
	}
Else If(ActivatorTID() >= M_EntityTID && ActivatorTID() <= (M_EntityTID+6499))
	{
	//log(s:"an M_EntiTID");
	FiringPlayer= ACS_NamedExecuteWithResult("core_gettarget"); //Actor is a player spawed entity, Returns the target of the activator
	}
else
	{
	//log(s:"a Player");
	FiringPlayer=ActivatorTID();
	}

PlayersTeam = GetPlayerInfo(FiringPlayer-1000, PLAYERINFO_TEAM);
For(int i = 0;i < GetMaxEntities(); i++)
	{
	Target_TID = i+1000;
	GiveClearance = false;
	If(PlayerInGame(i) && xyzDistance(0,Target_TID) < GiveRadius) // && FiringPlayer!=Target_TID
		{
			if((GiveType & RG_LOS) && !CheckSight(0,Target_TID,0)) {Continue; /*Log(s:"Not giving to ",i:Target_TID);*/}
			if((GiveType & RG_SELF) && FiringPlayer == Target_TID) {GiveClearance = True;}
			if(TeamGame)
			{
				if((GiveType & RG_TEAM) && PlayersTeam == GetPlayerInfo(i, PLAYERINFO_TEAM) && FiringPlayer != Target_TID) {GiveClearance = True;}
				if((GiveType & RG_ENEMY) && PlayersTeam != GetPlayerInfo(i, PLAYERINFO_TEAM)) {GiveClearance = True;}
			}
			else
			{
				if((GiveType & RG_TEAM) && FiringPlayer == Target_TID) {GiveClearance = True;}
				if((GiveType & RG_ENEMY) && FiringPlayer != Target_TID) {GiveClearance = True;}				
			}
			
			
			if(GiveClearance)
			{
				//GiveActorInventory(Target_TID,"PackageID", GiveID);
				//GiveActorInventory(Target_TID,"GivePackage", 1);
				GivePackage = StrParam(s:"RadiusGiveItem_",i:GiveID);
				GiveActorInventory(Target_TID,GivePackage, 1);
			}

		}
	}
}
#endregion
//#endregion

//#region -=- Medivision -=-
#region -=- Medivision -=-

Str TinyBarSprite[21] = {
    "TinyBar0",
    "TinyBar1",
    "TinyBar2",
    "TinyBar3",
    "TinyBar4",
    "TinyBar5",
    "TinyBar6",
    "TinyBar7",
    "TinyBar8",
    "TinyBar9",
    "TinyBar10",
    "TinyBar11",
    "TinyBar12",
    "TinyBar13",
    "TinyBar14",
    "TinyBar15",
    "TinyBar16",
    "TinyBar17",
    "TinyBar18",
    "TinyBar19",
    "TinyBar20",
    };
       
    function str TinyBarHealth (int TargTID)
    {
    int output;
    int HealthPercent;
    int PlayerCurrentHealth;// = GetActorProperty(0,APROP_Health);
    int PlayerMaxHealth;// = GetActorProperty(0,APROP_SpawnHealth);
    int OverHealth;
    
        if(GetActorProperty(TargTID,APROP_HEALTH)<=0){PlayerCurrentHealth = 1; }
            Else{PlayerCurrentHealth = GetActorProperty(TargTID,APROP_Health);}
        if(GetActorProperty(TargTID,APROP_SpawnHealth)<=0){PlayerMaxHealth = 100; }
            Else{PlayerMaxHealth = GetActorProperty(TargTID,APROP_SpawnHealth);}
            
    HealthPercent = ((PlayerCurrentHealth*100)/PlayerMaxHealth);
    OverHealth = HealthPercent-100;
     if(OverHealth < 0){OverHealth = 0;}
      if(HealthPercent > 100){HealthPercent = 100;}
    
    HealthPercent = HealthPercent / 10;
    OverHealth = OverHealth / 5;
     
    HealthPercent =  HealthPercent + OverHealth;
    if(HealthPercent > 20){HealthPercent = 20;}
    if(HealthPercent < 0){HealthPercent = 0;}
    return (TinyBarSprite[HealthPercent]);
    }
     
    script "MSTD_MedivisionScript" (int Weapon) CLIENTSIDE
    { 
    if(Weapon==1){str WeaponRequired = GetWeapon();}
	int Target_TID;
	//int CamTID = C_TID + ConsolePlayerNumber();
	int ViewerTID;
    int PlayersTeam;
    str TeamTag; 
	
    if(ACS_ExecuteWithResult(975,1)!=1){terminate;}
    
    Switch(PlayerTeam())
        {
        Case 0: TeamTag = "_Light"; Break;
        Case 1: TeamTag = "_Wily"; Break;
        Case 2: TeamTag = "_Cossack"; Break;
        Case 3: TeamTag = "_King"; Break;
        }
    
    while(GetActorProperty(ActivatorTID(), APROP_HEALTH) > 0 && !CheckActorInventory(ActivatorTID(),"CopyRobotUnmorphed"))
        {
		//if(cam_mode[ConsolePlayerNumber()] == ON){ViewerTID = CamTID;}
		//else{}
		ViewerTID = 0;

        Delay(1);
        if(Weapon==1 && StrIcmp(GetWeapon(),WeaponRequired)!=0){terminate;}
        PlayersTeam = GetPlayerInfo(ActivatorTID()-1000, PLAYERINFO_TEAM);
        For(int p = 0; p < GetMaxEntities(); p++)
            {
            Target_TID = p+1000;
            If(PlayerInGame(p)
                && p+1000 != ActivatorTID()
                && (xyzDistance(ViewerTID,Target_TID) < 1900) 
                && PlayersTeam == GetPlayerInfo(p, PLAYERINFO_TEAM)
                && Checksight(ViewerTID,Target_TID,0))
                {
                if(CheckActorInventory(Target_TID,"CannotUseHealing")){SpawnForced(StrParam(s:TinyBarHealth(Target_TID),s:TeamTag,s:"_NoHeal"),GetActorX(Target_TID),GetActorY(Target_TID),GetActorZ(Target_TID) + (65 << 16));}
                else{if(ConsolePlayerNumber() == PlayerNumber ()){SpawnForced(StrParam(s:TinyBarHealth(Target_TID),s:TeamTag),GetActorX(Target_TID),GetActorY(Target_TID),GetActorZ(Target_TID) + (65 << 16));}}
                }
            }
        }
    }

#endregion
//#endregion

//#region -=- Healing Scripts -=-
#region -=- Healing Scripts -=-


Script "MSTD_HealthPercent" (int Pointer, int Type, int perval)
{

SetResultValue(GetHealthPercent(Pointer,Type,perval));
}

Script "MSTD_Basic(Over)Heal" (int Pointer, int HealAmount, int Overheal ) 
{
int OverhealMax = Overheal+100;
if(OverhealMax<=100){OverhealMax=101;}
if(OverhealMax>150){OverhealMax=150;}
if(Pointer!=0){SetActivator(0,Pointer);}
int MaxHealth = GetActorProperty(0,APROP_SPAWNHEALTH);

if(MaxHealth==0){MaxHealth=100;}
for(int g=1;g<=HealAmount;g++)
    {
    if(GetActorProperty(0,APROP_Health)<MaxHealth){HealThing(1,MaxHealth);}
    else if(ACS_NamedExecuteWithResult("MSTD_HealthPercent",0)<OverhealMax && Overheal>=1){GiveInventory("BasicOverhealItem",1);}
    }
}


Script "MSTD_AreaHeal" (int Ammount, Int HealRadius)
{
int Target_TID;
int Target_Distance;
int FiringPlayer;
int PlayersTeam;
int TargetTeam;
int TeamGame = ACS_ExecuteWithResult(975, 1);


// - Returns the target of the activator -
if(ActivatorTID() <= 999){FiringPlayer= ACS_NamedExecuteWithResult("core_gettarget"); }
// - Actor is a player spawed entity, Returns the target of the activator
else If(ActivatorTID() >= EntityTID && ActivatorTID() <= (EntityTID+6499)){FiringPlayer= ACS_NamedExecuteWithResult("core_gettarget"); }
else{FiringPlayer=ActivatorTID();}

PlayersTeam = GetPlayerInfo(FiringPlayer-1000, PLAYERINFO_TEAM);
For(int i = 0;i < GetMaxEntities(); i++)
	{
	Target_TID = i+1000;
	TargetTeam = GetPlayerInfo(i, PLAYERINFO_TEAM);
	If(PlayerInGame(i) && PlayersTeam == TargetTeam && xyzDistance(0,Target_TID) < HealRadius) // && FiringPlayer!=Target_TID
		{
		if(FiringPlayer-1000 == i){ACS_NamedExecuteAlways("MSTD_HealTID",0,Target_TID,Ammount);}
		else{ACS_NamedExecuteAlways("MSTD_HealTID",0,Target_TID,Ammount,1);}
		}
	}


}

Script "MSTD_HealTID" (int TargTID, int HealAmount)
{
int HealerTID = ACS_NamedExecuteWithResult("core_gettarget");
int PayEXP;
SetActivator(TargTID);
int MaxHealth = GetActorProperty(0,APROP_SPAWNHEALTH);
if(MaxHealth==0){MaxHealth=100;}
for(int g=1;g<=HealAmount;g++)
    {
    if(GetActorProperty(0,APROP_Health)<MaxHealth && GetActorProperty(0,APROP_Health)>0)
	{HealThing(1,MaxHealth); PayEXP++;}
	}
	
}

Script "MSTD_HealPointer" (int Pointer, int HealAmount)
{
int HealerTID = ACS_NamedExecuteWithResult("core_gettarget");
int PayEXP;
if(Pointer!=0){SetActivator(0,Pointer);}
int MaxHealth = GetActorProperty(0,APROP_SPAWNHEALTH);
if(MaxHealth==0){MaxHealth=100;}
for(int g=1;g<=HealAmount;g++)
    {
    if(GetActorProperty(0,APROP_Health)<MaxHealth && GetActorProperty(0,APROP_Health)>0)
		{HealThing(1,MaxHealth); PayEXP++;}
	}
	
}

Script "MSTD_OverhealDrain" (Int Tick)
{
if(GetActorProperty(0,APROP_HEALTH) > Tick){SetActorProperty(0,APROP_HEALTH,(GetActorProperty(0,APROP_HEALTH)-Tick));
	GiveInventory("DaDiBuffer",Tick);}
}


#endregion
//#endregion

//#region -=- Blast Knockback -=-
#region -=- Blast Knockback -=-

//From Jaxof7, as well...most stuff here is.
int Boom_TargetTID;
int Boom_TargetTeam;
int Boom_X;
int Boom_Y;
int Boom_Z;

Script "Save_Boom" (void) 
{
Boom_X = GetActorX(0);
Boom_Y = GetActorY(0);
Boom_Z = GetActorZ(0);
SetActivator(0,AAPTR_TARGET);
Boom_TargetTID = ActivatorTID();
Boom_TargetTeam = getSelfTeam();
}


Script "Boom_IsMine" (void) 
{
SetResultValue(BoomIsMineFunc());
}

function bool BoomIsMineFunc(void)  {
	return (ActivatorTID()==Boom_TargetTID);
}

Script "Boom_IsEnemy" (void) 
{
SetResultValue(BoomIsEnemyFunc());
}

function bool BoomIsEnemyFunc(void)  {
	if(BoomIsMineFunc()) return false;
	if(Boom_TargetTeam==TEAM_NONE) return true;
	return(Boom_TargetTeam!=getSelfTeam());
}

Script "Boom_IsAlly" (void) 
{
SetResultValue(BoomIsAllyFunc());
}

function bool BoomIsAllyFunc(void)  {
	if(BoomIsMineFunc()) return false;
	if(Boom_TargetTeam==TEAM_NONE) return false;
	return(Boom_TargetTeam==getSelfTeam());
}

Script "BlastKnockback2" (int force, int range) 
{
int xDist = GetActorX(0) - Boom_X;
int yDist = GetActorY(0) - Boom_Y;
int angle = VectorAngle(xDist,yDist);
int xyDist = VectorLength(xDist,yDist);
int zDist = GetActorCenterZ(0) - Boom_Z;
//int zDist = GetActorZ(0) - Boom_Z;
int pitch = VectorAngle(xyDist,zDist);
int dist = VectorLength(xyDist,zDist);

			if(CheckPlayerProp(playernumber(),MasterProPList[17][PROP_NAME])){force += force*0.5>>16; if(force < 0){force = 0;};}
			if(CheckPlayerProp(playernumber(),MasterProPList[18][PROP_NAME])){force -= force*0.5>>16; if(force < 0){force = 0;};}

dist >>= 16;
//Printbold(i:dist,s:" ",i:range,s:" ",i:force);
if(dist<range) {
	dist = max(dist-36,0);
	range = max(range-36,1);
	force = (force*(range-dist)/range);
	//Printbold(i:dist,s:" ",i:range,s:" ",i:force);
	ThrustThing3Db(0,angle,pitch,force,force*5/2);
}
}

function void ThrustThing3Db(int tid, int angle, int pitch, int force, int zForce)  {
	//PrintBold(f:pitch);
	ThrustThing(angle>>8,(cos(pitch)*force)>>16,0,tid);
	ThrustThingZ(tid,(sin(pitch)*zForce)>>16,0,0);
}

function int GetActorCenterZ(int tid)  {
	return(GetActorZ(tid) + GetActorProperty(tid,APROP_Height)/2);
}

Script "BlastKnockback" (int BlastThrust, int ThrustForceH, int MaxRadius)
{
int userTID;
int userTeam;
Bool SelfThrustOnly = False;
int ThrustForce = BlastThrust;
	if(ThrustForce < 0) {SelfThrustOnly = true; ThrustForce = ThrustForce*-1;}
int AdditiveForce;
	if(MaxRadius < 0) {AdditiveForce = 1; MaxRadius = MaxRadius*-1;}

	if(ActivatorTID() == 0)
	{
		userTID = ACS_NamedExecuteWithResult("core_gettarget");
		userTeam = GetPlayerInfo(userTID - 1000, PLAYERINFO_TEAM);
	}
	else
	{
		userTID = ActivatorTID();
	}
	

int ActX = GetActorX(0);
int ActY = GetActorY(0);
//int ActHeight = GetActorProperty(0,APROP_HEIGHT) >>16;
int Dist;
int distdiff;
int ZThrust;
int XYThrust;
int targetTID;
int PlayerX;
int PlayerY;
int pitch;

int SubThrustForce,SubThrustForceH;

int FinalForce;
int FinalForceH;

//int ThrustDrop = NoNeg( (Dist/10) - MaxRadius) << 16;
//SetActivatorToTarget(0);

Bool ThrustApprove = true;

For(int q = 0;q < GetMaxEntities(); q++)
	{
		ThrustApprove = true;
		targetTID = q+1000;
		
		if(!PlayerInGame(q))
		{
			ThrustApprove = false;
		}
		
		if( (userTID != targetTID) && (SelfThrustOnly == True)){ThrustApprove = false;}
		if(ACS_ExecuteWithResult(975, 1) == 1)
		{
			if(userTeam == GetPlayerInfo(q, PLAYERINFO_TEAM) && userTID != targetTID)
			{
				ThrustApprove = false;
			}
		}
		
		if(ThrustApprove)
		{
			//log(s:"distance is ",i:xyzDistance(0, targetTID));
			if(xyzDistance(0, targetTID) < MaxRadius && checksight(0,targetTID,0) == True
			|| xyzDistance(0, targetTID) <20)
			{
			Dist = xyzDistance(0,targetTID);
		
			distdiff = NoNeg(Dist - MaxRadius);
			pitch = GetTargetPitch(targetTID,0);
			//VectorAngle(xyDistance(0, targetTID), GetActorZ(0) - GetActorZ(targetTID) >> 16);
			//log(s:"pitch relative to player ",i:q,s:" is ", f:pitch);
			//log(s:"Height is  ",i:ActHeight);

			//LightWeight & HeavyWeight modifiers
			SubThrustForce = ThrustForce;
			SubThrustForceH = ThrustForceH;

			if(CheckPlayerProp(q,MasterProPList[17][PROP_NAME]))
				{
				SubThrustForce += SubThrustForce*0.5>>16;;
				SubThrustForceH += SubThrustForceH*0.5>>16;;
				}

			if(CheckPlayerProp(q,MasterProPList[18][PROP_NAME]))
				{//log(s:"HeavyWeight  ");
				SubThrustForce -= SubThrustForce*0.5>>16;; if(SubThrustForce < 0){SubThrustForce = 0;}
				SubThrustForceH -= SubThrustForceH*0.5>>16;; if(SubThrustForceH < 0){SubThrustForceH = 0;}
				}


			if(xyzDistance(0, targetTID) > BASEBLASTMIN)
			{
			FinalForce = ceil(FixedMul(SubThrustForce << 16, 1.0 - FixedDiv(Dist, MaxRadius)));
			FinalForceH = ceil(FixedMul(SubThrustForceH << 16, 1.0 - FixedDiv(Dist, MaxRadius)));
			}
			Else
			{
			FinalForce = SubThrustForce;
			FinalForceH = SubThrustForceH;
			}
			ZThrust = (sin(pitch)*-FinalForce); //GetActorPitch(targetTID)
			XYThrust = (cos(pitch)*-FinalForceH);
			
			if (GetActorZ(targetTID) - GetActorFloorZ (targetTID) == 0){XYThrust = FixedMul(XYThrust,1.0);}
			//log(i:GetActorZ(targetTID) - GetActorFloorZ (targetTID));
			//log(s:"horizontal thrust is is  ",i:(FixedMul(XYThrust , 1.0 - fixedDiv(distdiff,100)))>> 16);
			PlayerX = GetActorX(targetTID);
			PlayerY = GetActorY(targetTID);
			
			ThrustThing(VectorAngle(ActX - PlayerX,ActY - PlayerY)>>8,(FixedMul(XYThrust , 1.0 - fixedDiv(distdiff,100)))>> 16,1,targetTID);
			thrustthingz(targetTID,(FixedMul(ZThrust , 1.0 - fixedDiv(distdiff,100)))>> 16,1,AdditiveForce);
		}
	}
}

}
#endregion
//#endregion

//#region -=- Arc limit -=-

int count;

script "Arc_Limit_Start" (void) CLIENTSIDE
{
count = 0;
}

script "Arc_Limit" (void) CLIENTSIDE
{
count++;
SetResultValue(count>50);
}

script "Arc_ClientSide" (void) CLIENTSIDE
{
	int u = UniqueTID();
	SetActivator(0,AAPTR_TARGET);
	//Log(i:consoleplayernumber(),s:" ",i:playernumber());
	if(consoleplayernumber() != playernumber()){
		SetResultValue(0);
	}
	else
	{SetResultValue(1);}
}

script "Arc_ClientSide2" (int TargTID) CLIENTSIDE
{
	//int u = UniqueTID();
	SetActivator(TargTID);
	//Log(i:consoleplayernumber(),s:" ",i:playernumber(),s:" ",s:GetActorClass(0));
	if(consoleplayernumber() != playernumber()){
		SetResultValue(0);
	}
	else
	{SetResultValue(1);}
}
//#endregion

Script "MSTD_ActorClassifier" (int TID, int CheckType)
{
bool output;
   
switch(CheckType)
	{
	case 0: if ((ClassifyActor(TID) & ACTOR_NONE)){output = true;} break;
	case 1: if ((ClassifyActor(TID) & ACTOR_WORLD)){output = true;} break;
	case 2: if ((ClassifyActor(TID) & ACTOR_PLAYER)){output = true;} break;
	case 3: if ((ClassifyActor(TID) & ACTOR_BOT)){output = true;} break;
	case 4: if ((ClassifyActor(TID) & ACTOR_VOODOODOLL)){output = true;} break;
	case 5: if ((ClassifyActor(TID) & ACTOR_MONSTER)){output = true;} break;
	case 6: if ((ClassifyActor(TID) & ACTOR_ALIVE)){output = true;} break;
	case 7: if ((ClassifyActor(TID) & ACTOR_DEAD)){output = true;} break;
	case 8: if ((ClassifyActor(TID) & ACTOR_MISSILE)){output = true;} break;
	case 9: if ((ClassifyActor(TID) & ACTOR_GENERIC)){output = true;} break;
	}

SetResultValue(output);
}

Script "HitSound" (void)
{
localAmbientSound("misc/metdie",127);
}

script "Spawn_SmallHealth_MSTD" (void)
{
SpawnNewWepFunc("SmallHealth_MSTD");
}

script "Spawn_SmallHealth2_MSTD" (void)
{
SpawnNewWepFunc("SmallHealth2_MSTD");
}

script "Spawn_BigHealth_MSTD" (void)
{
SpawnNewWepFunc("BigHealth_MSTD");
}

script "Spawn_BigHealth2_MSTD" (void)
{
SpawnNewWepFunc("BigHealth2_MSTD");
}

Script "CheckForAmmoHealth" (int Type)
{
int output;
Switch(Type)
	{
	default: Output = GetCvar("MSTD_SmallAmmoHealth"); Break;
	case 1: Output = GetCvar("MSTD_BigAmmoHealth"); Break;
	}
SetResultValue(output);
}

//Damage Over Time Script
script "DotDamager" (int damage, int TID, int Type)
{
setactivator(0,AAPTR_TARGET);
str DamType;
Switch(Type)
	{
	default: DamType = "FireDOT"; Break;
	Case 1: DamType = "PoisonDOT"; Break;
	}
thing_damage2(TID,damage,DamType);
}

script "HitKnockBack" (int force)
{
if(!ACS_NamedExecuteWithResult("MSTD_ActorClassifier",0,2)){Terminate;}
int pusher = ACS_NamedExecuteWithResult("Core_GetTarget", 0);
if(CheckProp(MasterProPList[17][PROP_NAME])){force += force*0.5>>16;} //Lightweight
if(CheckProp(MasterProPList[18][PROP_NAME])){force -= force*0.5>>16; if(force<0){force = 0;}} //HeavyWeight
int Vang = VectorAngle(GetActorX(0) - GetActorX(pusher), GetActorY(0) - GetActorY(pusher)) >> 8;
ThrustThing(Vang, force, 1, 0);
}


function bool OpenGLCvarClient(void)
{
return (getCvar("vid_renderer"));
}

script "MMBN_OpenGLCheck" (void) CLIENTSIDE
{
SetResultValue(OpenGLCvarClient());
}

Script "MassimoDamageRamp" (int MinDam, int MaxDam)
{
SetResultValue(MassimoDamageRamp(MinDam,MaxDam,AAPTR_TARGET));
}

function int MassimoDamageRamp(int MinDam, int MaxDam, int Pointer)
{
int HealthPer = GetHealthPercent(Pointer,0,0);
int Output = ValueMap(HealthPer,100,0,MinDam,MaxDam);
return(Output);
}



Script "SniperBusterRamp" (int hitCap, int MinDam, int MaxDam)
{
SetActivatorToTarget(0);
str WepName = STD_WhichWeaponName();
str WepName2 = StrLeft(WepName,StrLen(WepName)-StrLen("Wep"));
//log(s:WepName);
//log(s:WepName2);
int ItemCount = CheckInventory(StrParam(s:WepName2,s:"_HitCounter"));
if(ItemCount > hitCap){ItemCount = hitCap;}
int Output = ValueMap(ItemCount,0,hitCap,MinDam,MaxDam);
SetResultValue(Output);
}

Script "SearchManDamageRamp" (int MinDam, int MaxDam, int MinRange, int MaxRange)
{
	int Output = ValueMap(xyzDistance(0, ACS_NamedExecuteWithResult("core_gettarget")),MinRange,MaxRange,MinDam,MaxDam);
	Output = RoundToNth(Output,5);
	if(Output > MaxDam){Output = MaxDam;}
	else if(Output < MinDam){Output = MinDam;}
	SetResultValue(Output);
}



Script "CheckStatusGuard" (int Pointer, int Input)
{
Int Output;

/*
 * 0 = no status protection
 * 1 = Minor status protection
 * 2 = Major status protection
 *
 */ 


if(Pointer!=0){SetActivator(0,Pointer);}

if(!(ClassifyActor(0) & ACTOR_PLAYER))
	{Output = Output | STATUS_MAJOR;}

if(CheckInventory("PoisonMark")
||CheckInventory("BurnMark")
||CheckInventory("FrostbiteMark")
)
{Output = Output | STATUS_MAJOR;}

//if(CheckInventory("ProtectGuard")
//||CheckInventory("DetectGuard")
//||CheckInventory("SubGuard"))
//{Output = Output | STATUS_MAJOR | STATUS_MINOR | STATUS_STATS;}

    //if(CheckInventory("SafeguardPower"))
    //{Output = Output | STATUS_MAJOR | STATUS_MINOR | STATUS_SPECIALTY | STATUS_TAUNT;}

    //if(CheckInventory("MistFlag"))
    //{Output = Output | STATUS_STATS  | STATUS_MINOR | STATUS_TAUNT;}

    //if(CheckInventory("CleanseTag"))
    //{Output = Output | STATUS_STATS;}
SetResultValue(Output & Input);
}

Script "WepSpeedMod" (int Value)
{
int FixedValue = Value<<16;
//Check for mastery

if(CheckProp(MasterProPList[16][PROP_NAME])) {Value = 0.7; /*log(s:"Got Hefty!");*/}
if(MasteryCheck(GetThisWeaponType())) {Value += 0.1; /*log(s:"Got Mastery!");*/}
if(CheckProp(MasterProPList[14][PROP_NAME])) 
	{
	/*log(s:"Got Speedrunner!");*/
	if(Value >= 0.9)Value += 0.2; 
	else if(Value >= 0.7)Value += 0.1;
	}
	if(CheckForSpecialist()) {Value += 0.1; /*log(s:"Got Specialist!");*/}

//IsBladeParryActive();

//Quickman's Speed passive
if(CheckInventory("IsQuickman")){Value += 0.2*CheckInventory("AtomicSpeedLevel");}

if(Value != GetActorProperty(0,APROP_SPEED))
	{
	//log(i:Value,s:" ",i:GetActorProperty(0,APROP_SPEED),s:" ",f:Value,s:" ",f:GetActorProperty(0,APROP_SPEED));
	SetActorPRoperty(0,APROP_SPEED,Value);
	//TriggerAcrobatCheck();
	}

}

script "SpeedUpdate" (int Value)
{
//used to change weapon speeds without switching weapons, this stuff will usually be counted
//on actual weapon switches, like quickman's class passive

SetActorPRoperty(0,APROP_SPEED,GetActorProperty(0,APROP_SPEED)+Value);
}

Script "DetectFlicker" (void)
{

bool FlickerState;

SetActorProperty(0,Aprop_Renderstyle,STYLE_None);
FlickerState = false;

while(GetActorProperty(0, APROP_HEALTH)>0
&& CheckInventory("EvasionState") > 0
    ){
        Delay(2);

        Switch(FlickerState)
            {
                case 0: SetActorProperty(0,Aprop_Renderstyle,STYLE_Translucent); FlickerState = true; break;
                case 1: SetActorProperty(0,Aprop_Renderstyle,STYLE_None); FlickerState = false; break;
            }
    }

    SetActorProperty(0,Aprop_Renderstyle,STYLE_Translucent);
}


Script "CheckMeleeWep" (void)
{
int Output;
if(GetThisWeaponType() & WF_MELEE){Output = true;}
SetResultValue(Output);
}


script "HealerShotIdentify"  (VOID) 
{

	int FiringPlayer= ACS_NamedExecuteWithResult("Core_GetTarget", 0) - 1000;
    int TracerPlayer= ACS_NamedExecuteWithResult("Core_GetTracer", 0) - 1000;
    int Output;
    if( GetPlayerInfo(TracerPlayer, PLAYERINFO_TEAM) == GetPlayerInfo(FiringPlayer, PLAYERINFO_TEAM))
    {
        Output = 1;
    }

    setResultValue(Output);
}

//======|Damage Faloff Formula Script
Script "DamageRate" (int ModDamage, int DistStart, int RampRate) //DamageDropoff Script
{
SetResultValue(DamageRate(ModDamage, DistStart, RampRate));
}

function int DamageRate (int ModDamage, int DistStart, int RampRate) //DamageDropoff Script
{
int Damage = NoNeg(ModDamage - NoNeg(xyzdistance(0, ACS_NamedExecuteWithResult("core_gettarget"))-DistStart)/RampRate);
return(Damage);
}


Script "DMinMax" (int MinD, int MaxD)
{ //Picks the highest of the 2 values
int Output = MinD;
if(MaxD > MinD) {Output = MaxD;}
SetResultValue(Output);
}

Script "DMGR" (int DMG1, int Range1, int DMG2, int Range2) //Damage Rate Script
{

//Range 1 is the closest range threshold, Range 2 is the furthest

int Dist = xyzdistance(0, ACS_NamedExecuteWithResult("Core_GetTarget", 0));
int Damage;
if(Dist <= Range1*ZDMETER) //Within effective range
	{Damage = DMG1;}
else if(Dist <= Range2*ZDMETER) //Beyond effective range
	{
	Damage = DMG2;
	}
SetResultValue(Damage);
}

Script "HealRamp" (Int HealMin, Int HealMax, int Pointer)
{
if(Pointer!=0){SetActivator(0,Pointer);}
int HitTime = GetActorPowerupTics(0,"HealRampPower");
int timeMax = 350;
int rampPerc = (HitTime*100)/timeMax;

int output = (HealMax*(100 - rampPerc))/100;


if (output < HealMin){output = HealMin;}
if (output > HealMax){output = HealMax;}
SetResultValue(output);
}

Script "WeaponReload" (int AmmoCount)
{
int ThisWeapon = STD_WhichWeapon();
str WepAmmoName = MasterWepList[ThisWeapon][2];
int WepAmmoCount = GetAmmoCapacity(WepAmmoName);

if(!AmmoCount || AmmoCount>WepAmmoCount){AmmoCount = WepAmmoCount;}

GiveInventory(WepAmmoName,AmmoCount);
}

Script "CheckAmmoFull" (void)
{
int ThisWeapon = STD_WhichWeapon();
str WepAmmoName = MasterWepList[ThisWeapon][2];
int WepAmmoCount = GetAmmoCapacity(WepAmmoName);

SetResultValue(CheckInventory(WepAmmoName) == WepAmmoCount);
}

Script "TurretReticleWarper" (void) CLIENTSIDE
{
	int Player = ACS_NamedExecuteWithResult("core_gettarget",0);
	
	// Loop if shield is active
	while(GetActorProperty(Player, APROP_HEALTH)>0
	&& CheckActorInventory(Player, "TurretReticleHold") > 0
	){
		Delay(1);
	}
	
	// Remove
	Thing_Remove(0);
}

Script "HealthGenSyncher" (void) 
{
	int BaseTID = ActivatorTID();
	int Owner = ACS_NamedExecuteWithResult("core_gettarget")-1000;
	int Team = GetPlayerInfo(Owner, PLAYERINFO_TEAM);
	str BaseName = "HealthGenBase";
			switch(Team)
			{
			Case 0:
			BaseName = StrParam(s:BaseName,s:"_B");
			break;
			Case 1:
			BaseName = StrParam(s:BaseName,s:"_R");
			break;
			Case 2:
			BaseName = StrParam(s:BaseName,s:"_G");
			break;
			Case 3:
			BaseName = StrParam(s:BaseName,s:"_O");
			break;
			}
		

	while(ThingCountName(BaseName,BaseTID)){
		Delay(1);
	}
	
	// Remove
	Thing_Remove(0);
}



script "TrapSensorIdentify"  (VOID) 
{

	int SensorPlayer= ACS_NamedExecuteWithResult("Core_GetTarget", 0) - 1000;
    int FiringPlayer= ACS_NamedExecuteWithResult("Core_GetMaster", 0) - 1000;
    int Output;
    if( GetPlayerInfo(SensorPlayer, PLAYERINFO_TEAM) == GetPlayerInfo(FiringPlayer, PLAYERINFO_TEAM))
    {
        Output = 1;
    }

    setResultValue(Output);
}


script "TIDCOUNTER" (int Tid)
{
setresultvalue(thingcount(T_NONE,Tid));
}

script "GetWeaponCharge" (void)
{
setresultvalue(CheckInventory("WeaponCharge"));
}


Script "StunnedFXWarper" (void) CLIENTSIDE
{
	int Player = ACS_NamedExecuteWithResult("core_gettarget",0);
	
	// Loop if shield is active
	while(GetActorProperty(Player, APROP_HEALTH)>0
	&& CheckActorInventory(Player, "StunMark") > 0
	){
		Delay(1);
	}
	
    // Remove
    SetActorState(0,"Death");
    Delay(17);
	Thing_Remove(0);
}

Script "TeleportSpotMark" (void)
{
    int pln = PlayerNumber();
    int tid = pln+1000;
    int ang = GetActorAngle(tid);
    If(ThingCount(0, pln+PLN_EXITUNITIMAGE)>0)
    {
        Thing_Remove(pln+PLN_EXITUNITIMAGE);
    }
    SpawnSpotForced("ExitUnitCentaurGhost",ActivatorTID(),pln+PLN_EXITUNITIMAGE,ang>>8);

    If(ThingCount(0, pln+PLN_EXITUNITPOINT)>0)
    {
        Thing_Remove(pln+PLN_EXITUNITPOINT);
    }
    SpawnSpotForced("TeleportDest2",ActivatorTID(),pln+PLN_EXITUNITPOINT,ang>>8);
}

Script "TeleportSpotMark2" (void)
{
    int pln = ACS_NamedExecuteWithResult("Core_GetTarget",0)-1000;
    int tid = pln+1000;
    int ang = GetActorAngle(0);
    If(ThingCount(0, pln+PLN_EXITUNITIMAGE)>0)
    {
        Thing_Remove(pln+PLN_EXITUNITIMAGE);
    }
    SpawnSpotForced("ExitUnitCentaurGhost",ActivatorTID(),pln+PLN_EXITUNITIMAGE,ang>>8);

    If(ThingCount(0, pln+PLN_EXITUNITPOINT)>0)
    {
        Thing_Remove(pln+PLN_EXITUNITPOINT);
    }
    SpawnSpotForced("TeleportDest2",ActivatorTID(),pln+PLN_EXITUNITPOINT,ang>>8);
}



//Hitscan based suck/blow, by jax
script "MSTD_SuctionCode" (int distRange, int angleRange, int suckPower, int type)
{
	distRange <<= 16;
	angleRange <<= 8;
	int owner = ACS_NamedExecuteWithResult("MSTD_GetPointerTID_147",2);
	if(CheckActorInventory(owner,"NoSourcePushFlag"))terminate;//$CBM (Fishy)
	int angle = GetActorAngle(owner);
	int pitch = pitchAdjust(GetActorPitch(owner));
	int team = ACS_ExecuteWithResult(143, 0);
	int x = GetActorX(0);
	int y = GetActorY(0);
	int z = GetActorZ(0);

	int xDist;
	int yDist;
	int zDist;
	int angleDist;
	int pitchDist;
	int dist;

	for(int i=0; i<MAX_PLAYERS; i++) {
		if(owner == 1000 + i)
			continue;
		if(CheckActorInventory(1000 +i, "NoPushFlag")){continue;}
		if((team==TEAM_NONE||isDifferentTeams(team,i))&&CheckSight(0,1000+i,0)) {
			xDist = GetActorX(1000+i) - x;
			yDist = GetActorY(1000+i) - y;
			angleDist = VectorAngle(xDist,yDist);
			if(abs(WrapAround(angleDist-angle))<angleRange){
				dist = fDistanceVal1(angleDist, xDist, yDist);
				zDist = GetActorZ(1000+i) + 28.0 - z;
				pitchDist = VectorAngle(dist, zDist);
				if(abs(WrapAround(pitchDist-pitch))<angleRange) {
					dist = fDistanceVal2(pitchDist, dist, zDist);
					if(dist<distRange) {
						ThrustThing((angle >> 8), suckPower, 1, 1000+i);
						if(type>0){
							GiveActorInventory(1000+i,"TempPitProtect_P",1);
						}
						switch(abs(type)) {
						//	case 101://Targeter Type
						//		GiveActorInventory(1000+i,"HomingLockGiver",1);
						//		break;
						//	case 20://Dynamo
						//		GiveActorInventory(1000+i,"HomingLockGiver",1);
						//		break;
							case 4://HSH Suck Cold
								GiveActorInventory(1000+i,"IcemanSlowPickup",1);
								break;
							case 2://Dust Suck
								if(ACS_NamedExecuteWithResult("MSTD_IsPlayerAlive",i+1000)){
									//GiveActorInventory(owner,"CrushEmAmmo",2);
								}
								break;
							case 1://Null for Negative 1
								break;
							default://Blow
								Log(i:type,s:" >> Invalid Number for script C_JAX_SUCKRECODE (422)");
								break;
						}
					}
				}
			}
		}
	}
	
}

script "MSTD_GetPointerTID_147" (int Swap)
{
	Switch(Swap) {
		Default:
			Log(i:Swap,s:" >> Invalid Pointer for MSTD_GetPointerTID_147");
			break;
		Case 0://Default
			break;
		Case 1://Null
		Case 2://Target
		Case 4://Master
		Case 8://Tracer
		Case 16://Player_GetTarget
		Case 32://Player_GetConversation
		Case 16384://FriendPlayer
			SetActivator(0,Swap);
			break;
	}
	SetResultValue(ActivatorTID());
}


Script "SynchTargetSpecies" (void) 
{
	int BaseTID = ActivatorTID();
	int Owner = ACS_NamedExecuteWithResult("core_gettarget")-1000;
	int Team = GetPlayerInfo(Owner, PLAYERINFO_TEAM);

	If(ACS_ExecuteWithResult(975, 1))
		{
		switch(Team)
			{
			Case 0:
			SetActorProperty(0,APROP_SPECIES,"LightMember");
			break;
			Case 1:
			SetActorProperty(0,APROP_SPECIES,"WilyMember");
			break;
			Case 2:
			SetActorProperty(0,APROP_SPECIES,"CossackMember");
			break;
			Case 3:
			SetActorProperty(0,APROP_SPECIES,"KingMember");
			break;
			}
		}
		Else{setactorproperty(0,APROP_SPECIES,strparam(s:"Player",i:Owner));}
}

//WallJump scripts from CSCCDC and CBM.

Script "CSCACS_WallJump" (void)
{
Delay(2);
int Buttons;
int OlDButtons;
int WallJumpLimit = CheckInventory("WallJumpLimit");
If(WallJumpLimit == 0){SetInventory("WallJumpLimit", 10); WallJumpLimit = 10;}
While(GetActorProperty(0,APROP_Health) > 0 && CheckInventory("CanWallJumpFlag"))
	{
	Buttons = GetPlayerInput(-1, INPUT_BUTTONS);
	if(CheckInventory("JumpCancler")==0 && CSLTButtonCheck(Buttons, OldButtons, BT_JUMP)==1) 
		{
		If(WallJumpLimit > 0)
			{
			GiveInventory("WallJumping",1);
			Delay(1);
			If(CheckInventory("WallJumped"))
				{
				WallJumpLimit--;
				TakeInventory("WallJumped", 1);
				}
			}
		Delay(10);
		}

	If(CheckInventory("JumpCancler") && GetActorVelZ(0) == 0.0){WallJumpLimit = CheckInventory("WallJumpLimit");}
	OldButtons=Buttons;
	delay(1);
	}
}

script "CSACS_WallJump" (int Force, int BonusJump)
{
	//SetActivatorToTarget(0);
	//int JumpFixAngle = 0;
	int JumpAngByte = 0;
	int TotalAngles = 0;
    if (CheckInventory("WallN") && !CheckInventory("WallS")) {
		JumpAngByte += 128;
		TotalAngles++;
	}
    if (/*CheckInventory("WallS") &&*/ !CheckInventory("WallN")) {
		JumpAngByte += 256;
		TotalAngles++;
	}
	if (CheckInventory("WallE") && !CheckInventory("WallW")) {
	    JumpAngByte += 64;
		TotalAngles++;
	}
	if (CheckInventory("WallW") && !CheckInventory("WallE")) {
	    JumpAngByte += 192;
		TotalAngles++;
	}
	if (/*CheckInventory("WallS") && */ !CheckInventory("WallN") && CheckInventory("WallE") && !CheckInventory("WallW")) { //Somewhere, a mathematician is crying.
	    JumpAngByte = 32;
		TotalAngles = 1;
	}
	if (TotalAngles>0) {
		JumpAngByte /= TotalAngles;
		ThrustThing(((GetActorAngle(0) >> 8) + JumpAngByte),(Force*GetActorProperty(0,APROP_SPEED))>>16,1);
		SetActorVelocity(0,GetActorVelX(0),GetActorVelY(0),GetActorProperty(0,APROP_JumpZ)+BonusJump*1.0,0,0);
		//ThrustThingZ(0,(GetActorProperty(0,APROP_JumpZ) >> 16) * 4 + BonusJump,0,0);
	}
}
