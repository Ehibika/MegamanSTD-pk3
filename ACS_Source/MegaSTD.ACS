#library "MEGASTD"
#include "zcommon.acs"
#include "8BDMLIB.ACS"

#import "a_Core.acs"
#import "a_Loadout.acs"

//#region -=- Hit Event -=-
#region -=- Hit Event -=-
script "MSTD_HitEvents" (int type, int arg1, int arg2) EVENT
{
int Damage = arg1;
if(type == 11) //GAMEEVENT_ACTOR_DAMAGED 
{


if(CheckInventory("LT_Armor"))
	{
	TakeInventory("LT_Armor",arg1);
	GiveInventory("OverHealHealth",arg1);
	
	//I can change the end damage, but I'm resorting to
	//my old Damage interception tricks just so hits still
	//Trigger painstates.
	
	/*
	Damage -= CheckInventory("LT_Armor");
	TakeInventory("LT_Armor",arg1);
	
	if(Damage<=0){Damage = 1; GiveInventory("HealthBonus",1);}
	*/
	}

SetResultValue(Damage);
}
}
#endregion
//#endregion

//#region -=- EntiTID -=-
#region -=- EntiTID -=-

#LIBDEFINE EntityTID 480000
#LIBDEFINE ENTITY_CAP 10 //for masterscrub, to reduce the loops
Script "GiveEntiTID" (Int EntityID)
{
/*
I don't think puns make for good programming practices but why not? hopefully I won't pay for this

anyways, this is for entities that you are only allowed one of per person, this gives them a TID
formatted in the following way:

EntiTID Tag | Player Number | Entity ID
48|00|00
*/
int OwnerTID = ACS_NamedExecuteWithResult("core_gettarget");
if(OwnerTID < 1000){Terminate;}

Int P = (OwnerTID-1000)*100;
int ETID = EntityTID+P+EntityID;

/*
Now, let's kill any actor that already has this ETID
*/

if (ThingCount(T_NONE,ETID)){Thing_Remove(ETID); /*ACS_NamedExecuteAlways("Client_Thing_Remove",0,ETID);*/}
Thing_ChangeTID(0,EntityTID+P+EntityID);
}

#endregion
//#endregion

//#region -=- Check EntiTID -=-
#region -=- Check EntiTID -=-


Script "CheckEntiTID" (int Pointer, Int EntityID)
{

	if(Pointer!=0){SetActivator(0,Pointer);}

Int P = (ActivatorTID()-1000)*100;
int ETID = EntityTID+P+EntityID;

bool Output = false;

if (ThingCount(T_NONE,ETID)){Output = true;}
SetResultValue(Output);

}

#endregion
//#endregion

//#region -=- Multi EntiTID -=-
#region -=- Multi EntiTID -=-

#LIBDEFINE M_ENTITYTID 4900000
#LIBDEFINE M_ENTITY_CAP 6 //for masterscrub, to reduce the loops
int M_EntityRecord[64];
Script "GiveM_EntiTID" (Int EntityID, int EntityCap)
{
/*
This one allows for multiple entities to be spawned but only up to 9. and if a new one is spawned beyond the cap, the old one get's replaced

EntiTID Tag | Player Number | Entity ID | Entity count
49|00|00|0
*/

int OwnerTID = ACS_NamedExecuteWithResult("core_gettarget");
Int P = (OwnerTID-1000)*1000;
int M_ETID = M_ENTITYTID+(P)+(EntityID*100);
int EntityNum;
bool SpawnComplete;

while(!SpawnComplete)
	{
		if(EntityNum >= EntityCap)
			{
				Thing_Remove(M_ETID);
				//ACS_NamedExecuteAlways("Client_Thing_Remove",0,M_ETID);
				for(int i = 1; i < EntityCap; i++)
				{
					Thing_ChangeTID(M_ETID+i,M_ETID+i-1);
					//ACS_NamedExecuteAlways("Client_Thing_ChangeTID",0,M_ETID+i,M_ETID+i-1);
				}
				EntityNum = 0;
			}
		if(ThingCount(T_NONE,M_ETID+EntityNum)){EntityNum++;}
		else{SpawnComplete = true;}

	}
Thing_ChangeTID(0,M_ETID+EntityNum);
}
//#endregion

//#region -=- Radius Give -=-
#region -=- Radius Give -=-

#DEFINE RG_SELF 1
#DEFINE RG_TEAM 2
#DEFINE RG_ENEMY 4
#DEFINE RG_LOS 8

script "STD_RadiusGive" (int GiveID, int GiveRadius, int GiveType)
{ 
int Target_TID;
int Target_Distance;
int FiringPlayer;
int PlayersTeam;
int TeamGame = ACS_ExecuteWithResult(975, 1);
str GivePackage;
Bool GiveClearance;

//GiveType works like a bitwise flag
If(ActivatorTID() <= 999)
	{
	//log(s:"an Actor");
	FiringPlayer= ACS_ExecuteWithResult(257, 0); //Returns the target of the activator
	}
Else If(ActivatorTID() >= EntityTID && ActivatorTID() <= (EntityTID+6499))
	{
	//log(s:"an EntiTID");
	FiringPlayer= ACS_ExecuteWithResult(257, 0); //Actor is a player spawed entity, Returns the target of the activator
	}
Else If(ActivatorTID() >= M_EntityTID && ActivatorTID() <= (M_EntityTID+6499))
	{
	//log(s:"an M_EntiTID");
	FiringPlayer= ACS_ExecuteWithResult(257, 0); //Actor is a player spawed entity, Returns the target of the activator
	}
else
	{
	//log(s:"a Player");
	FiringPlayer=ActivatorTID();
	}
PlayersTeam = GetPlayerInfo(FiringPlayer-1000, PLAYERINFO_TEAM);
For(int i = 0;i < GetMaxEntities(); i++)
	{
	Target_TID = i+1000;
	GiveClearance = false;
	If(PlayerInGame(i) && xyzDistance(0,Target_TID) < GiveRadius) // && FiringPlayer!=Target_TID
		{
			if((GiveType & RG_LOS) && !CheckSight(0,Target_TID,0)) {Continue; /*Log(s:"Not giving to ",i:Target_TID);*/}
			if((GiveType & RG_SELF) && FiringPlayer == Target_TID) {GiveClearance = True;}
			if(TeamGame)
			{
				if((GiveType & RG_TEAM) && PlayersTeam == GetPlayerInfo(i, PLAYERINFO_TEAM) && FiringPlayer != Target_TID) {GiveClearance = True;}
				if((GiveType & RG_ENEMY) && PlayersTeam != GetPlayerInfo(i, PLAYERINFO_TEAM)) {GiveClearance = True;}
			}
			else
			{
				if((GiveType & RG_TEAM) && FiringPlayer == Target_TID) {GiveClearance = True;}
				if((GiveType & RG_ENEMY) && FiringPlayer != Target_TID) {GiveClearance = True;}				
			}
			
			
			if(GiveClearance)
			{
				//GiveActorInventory(Target_TID,"PackageID", GiveID);
				//GiveActorInventory(Target_TID,"GivePackage", 1);
				GivePackage = StrParam(s:"RadiusGiveItem_",i:GiveID);
				GiveActorInventory(Target_TID,GivePackage, 1);
			}

		}
	}
}
#endregion
//#endregion

//#region -=- Medivision -=-
#region -=- Medivision -=-

Str TinyBarSprite[21] = {
    "TinyBar0",
    "TinyBar1",
    "TinyBar2",
    "TinyBar3",
    "TinyBar4",
    "TinyBar5",
    "TinyBar6",
    "TinyBar7",
    "TinyBar8",
    "TinyBar9",
    "TinyBar10",
    "TinyBar11",
    "TinyBar12",
    "TinyBar13",
    "TinyBar14",
    "TinyBar15",
    "TinyBar16",
    "TinyBar17",
    "TinyBar18",
    "TinyBar19",
    "TinyBar20",
    };
       
    function str TinyBarHealth (int TargTID)
    {
    int output;
    int HealthPercent;
    int PlayerCurrentHealth;// = GetActorProperty(0,APROP_Health);
    int PlayerMaxHealth;// = GetActorProperty(0,APROP_SpawnHealth);
    int OverHealth;
    
        if(GetActorProperty(TargTID,APROP_HEALTH)<=0){PlayerCurrentHealth = 1; }
            Else{PlayerCurrentHealth = GetActorProperty(TargTID,APROP_Health);}
        if(GetActorProperty(TargTID,APROP_SpawnHealth)<=0){PlayerMaxHealth = 100; }
            Else{PlayerMaxHealth = GetActorProperty(TargTID,APROP_SpawnHealth);}
            
    HealthPercent = ((PlayerCurrentHealth*100)/PlayerMaxHealth);
    OverHealth = HealthPercent-100;
     if(OverHealth < 0){OverHealth = 0;}
      if(HealthPercent > 100){HealthPercent = 100;}
    
    HealthPercent = HealthPercent / 10;
    OverHealth = OverHealth / 5;
     
    HealthPercent =  HealthPercent + OverHealth;
    if(HealthPercent > 20){HealthPercent = 20;}
    if(HealthPercent < 0){HealthPercent = 0;}
    return (TinyBarSprite[HealthPercent]);
    }
     
    script "MSTD_MedivisionScript" (int Weapon) CLIENTSIDE
    { 
    if(Weapon==1){str WeaponRequired = GetWeapon();}
	int Target_TID;
	//int CamTID = C_TID + ConsolePlayerNumber();
	int ViewerTID;
    int PlayersTeam;
    str TeamTag; 
	
    if(ACS_ExecuteWithResult(975,1)!=1){terminate;}
    
    Switch(PlayerTeam())
        {
        Case 0: TeamTag = "_Light"; Break;
        Case 1: TeamTag = "_Wily"; Break;
        Case 2: TeamTag = "_Cossack"; Break;
        Case 3: TeamTag = "_King"; Break;
        }
    
    while(GetActorProperty(ActivatorTID(), APROP_HEALTH) > 0 && !CheckActorInventory(ActivatorTID(),"CopyRobotUnmorphed"))
        {
		//if(cam_mode[ConsolePlayerNumber()] == ON){ViewerTID = CamTID;}
		//else{}
		ViewerTID = 0;

        Delay(1);
        if(Weapon==1 && StrIcmp(GetWeapon(),WeaponRequired)!=0){terminate;}
        PlayersTeam = GetPlayerInfo(ActivatorTID()-1000, PLAYERINFO_TEAM);
        For(int p = 0; p < GetMaxEntities(); p++)
            {
            Target_TID = p+1000;
            If(PlayerInGame(p)
                && p+1000 != ActivatorTID()
                && (xyzDistance(ViewerTID,Target_TID) < 900) 
                && PlayersTeam == GetPlayerInfo(p, PLAYERINFO_TEAM)
                && Checksight(ViewerTID,Target_TID,0))
                {
                if(CheckActorInventory(Target_TID,"CannotUseHealing")){SpawnForced(StrParam(s:TinyBarHealth(Target_TID),s:TeamTag,s:"_NoHeal"),GetActorX(Target_TID),GetActorY(Target_TID),GetActorZ(Target_TID) + (65 << 16));}
                else{if(ConsolePlayerNumber() == PlayerNumber ()){SpawnForced(StrParam(s:TinyBarHealth(Target_TID),s:TeamTag),GetActorX(Target_TID),GetActorY(Target_TID),GetActorZ(Target_TID) + (65 << 16));}}
                }
            }
        }
    }

#endregion
//#endregion

//#region -=- Healing Scripts -=-
#region -=- Healing Scripts -=-


Script "MSTD_HealthPercent" (int Pointer, int Type, int perval)
{
int HealthPercent;
int PlayerCurrentHealth;
int PlayerMaxHealth;
int MaxHPCache;
int TargTID;

if(Pointer>0){TargTID = ACS_NamedExecuteWithResult("core_getptrtid",Pointer);}
else {TargTID = ActivatorTID();}

if(GetActorProperty(TargTID,APROP_HEALTH)<=0){PlayerCurrentHealth = 1; }
else{PlayerCurrentHealth = GetActorProperty(TargTID,APROP_Health);}

MaxHPCache = GetActorProperty(TargTID,APROP_SpawnHealth); 

	
if(MaxHPCache<=0){PlayerMaxHealth = 1; }
else{PlayerMaxHealth = MaxHPCache;}

// Type 0 = current percentage of health
// Type 1 = Value of Health at that percentage
// Type 2 = Current Remaining HP

Switch (Type)
	{
	default : HealthPercent = ((PlayerCurrentHealth*100)/PlayerMaxHealth); Break;
	Case 1 : HealthPercent = (fixeddiv(PlayerMaxHealth,100)*perval) >> 16; Break;
	Case 2 : HealthPercent = PlayerCurrentHealth; Break;
	}

SetResultValue(HealthPercent);
}

Script "MSTD_Basic(Over)Heal" (int Pointer, int HealAmount, int Overheal ) //to be phased out
{
int OverhealMax = Overheal+100;
if(OverhealMax<=100){OverhealMax=101;}
if(OverhealMax>150){OverhealMax=150;}
if(Pointer!=0){SetActivator(0,Pointer);}
int MaxHealth = GetActorProperty(0,APROP_SPAWNHEALTH);

if(MaxHealth==0){MaxHealth=100;}
for(int g=1;g<=HealAmount;g++)
    {
    if(GetActorProperty(0,APROP_Health)<MaxHealth){HealThing(1,MaxHealth);}
    else if(ACS_NamedExecuteWithResult("MSTD_HealthPercent",0)<OverhealMax && Overheal>=1){GiveInventory("BasicOverhealItem",1);}
    }
}


Script "MSTD_AreaHeal" (int Ammount, Int HealRadius)
{
int Target_TID;
int Target_Distance;
int FiringPlayer;
int PlayersTeam;
int TargetTeam;
int TeamGame = ACS_ExecuteWithResult(975, 1);


// - Returns the target of the activator -
if(ActivatorTID() <= 999){FiringPlayer= ACS_ExecuteWithResult(257, 0); }
// - Actor is a player spawed entity, Returns the target of the activator
else If(ActivatorTID() >= EntityTID && ActivatorTID() <= (EntityTID+6499)){FiringPlayer= ACS_ExecuteWithResult(257, 0); }
else{FiringPlayer=ActivatorTID();}

PlayersTeam = GetPlayerInfo(FiringPlayer-1000, PLAYERINFO_TEAM);
For(int i = 0;i < GetMaxEntities(); i++)
	{
	Target_TID = i+1000;
	TargetTeam = GetPlayerInfo(i, PLAYERINFO_TEAM);
	If(PlayerInGame(i) && PlayersTeam == TargetTeam && xyzDistance(0,Target_TID) < HealRadius) // && FiringPlayer!=Target_TID
		{
		if(FiringPlayer-1000 == i){ACS_NamedExecuteAlways("MSTD_HealTID",0,Target_TID,Ammount);}
		else{ACS_NamedExecuteAlways("MSTD_HealTID",0,Target_TID,Ammount,1);}
		}
	}


}

Script "MSTD_HealTID" (int TargTID, int HealAmount)
{
int HealerTID = ACS_NamedExecuteWithResult("core_gettarget");
int PayEXP;
SetActivator(TargTID);
int MaxHealth = GetActorProperty(0,APROP_SPAWNHEALTH);
if(MaxHealth==0){MaxHealth=100;}
for(int g=1;g<=HealAmount;g++)
    {
    if(GetActorProperty(0,APROP_Health)<MaxHealth){HealThing(1,MaxHealth); PayEXP++;}
	}
	
}

Script "MSTD_HealPointer" (int Pointer, int HealAmount)
{
int HealerTID = ACS_NamedExecuteWithResult("core_gettarget");
int PayEXP;
if(Pointer!=0){SetActivator(0,Pointer);}
int MaxHealth = GetActorProperty(0,APROP_SPAWNHEALTH);
if(MaxHealth==0){MaxHealth=100;}
for(int g=1;g<=HealAmount;g++)
    {
    if(GetActorProperty(0,APROP_Health)<MaxHealth){HealThing(1,MaxHealth); PayEXP++;}
	}
	
}

#endregion
//#endregion

//#region -=- Blast Knockback -=-
#region -=- Blast Knockback -=-
Script "BlastKnockback" (int BlastThrust, int ThrustForceH, int MaxRadius)
{
int userTID;
int userTeam;
Bool SelfThrustOnly = False;
int ThrustForce = BlastThrust;
	if(ThrustForce < 0) {SelfThrustOnly = true; ThrustForce = ThrustForce*-1;}
int AdditiveForce;
	if(MaxRadius < 0) {AdditiveForce = 1; MaxRadius = MaxRadius*-1;}

	if(ActivatorTID() == 0)
	{
		userTID = ACS_ExecuteWithResult(257, 0);
		userTeam = GetPlayerInfo(userTID - 1000, PLAYERINFO_TEAM);
	}
	else
	{
		userTID = ActivatorTID();
	}
	

int ActX = GetActorX(0);
int ActY = GetActorY(0);
//int ActHeight = GetActorProperty(0,APROP_HEIGHT) >>16;
int Dist;
int distdiff;
int ZThrust;
int XYThrust;
int targetTID;
int PlayerX;
int PlayerY;
int pitch;

int FinalForce;
int FinalForceH;

//int ThrustDrop = NoNeg( (Dist/10) - MaxRadius) << 16;
//SetActivatorToTarget(0);

Bool ThrustApprove = true;

For(int q = 0;q < GetMaxEntities(); q++)
	{
		ThrustApprove = true;
		targetTID = q+1000;
		
		if(!PlayerInGame(q))
		{
			ThrustApprove = false;
		}
		
		if( (userTID != targetTID) && (SelfThrustOnly == True)){ThrustApprove = false;}
		if(ACS_ExecuteWithResult(975, 1) == 1)
		{
			if(userTeam == GetPlayerInfo(q, PLAYERINFO_TEAM) && userTID != targetTID)
			{
				ThrustApprove = false;
			}
		}
		
		if(ThrustApprove)
		{
			//log(s:"distance is ",i:xyzDistance(0, targetTID));
			if(xyzDistance(0, targetTID) < MaxRadius && checksight(0,targetTID,0) == True
			|| xyzDistance(0, targetTID) <20)
			{
			Dist = xyzDistance(0,targetTID);
		
			distdiff = NoNeg(Dist - MaxRadius);
			pitch = GetTargetPitch(targetTID,0);
			//VectorAngle(xyDistance(0, targetTID), GetActorZ(0) - GetActorZ(targetTID) >> 16);
			//log(s:"pitch relative to player ",i:q,s:" is ", f:pitch);
			//log(s:"Height is  ",i:ActHeight);
			if(xyzDistance(0, targetTID) > BASEBLASTMIN)
			{
			FinalForce = ceil(FixedMul(ThrustForce << 16, 1.0 - FixedDiv(Dist, MaxRadius)));
			FinalForceH = ceil(FixedMul(ThrustForceH << 16, 1.0 - FixedDiv(Dist, MaxRadius)));
			}
			Else
			{
			FinalForce = ThrustForce;
			FinalForceH = ThrustForceH;
			}
			ZThrust = (sin(pitch)*-FinalForce); //GetActorPitch(targetTID)
			XYThrust = (cos(pitch)*-FinalForceH);
			
			if (GetActorZ(targetTID) - GetActorFloorZ (targetTID) == 0){XYThrust = FixedMul(XYThrust,1.0);}
			//log(i:GetActorZ(targetTID) - GetActorFloorZ (targetTID));
			//log(s:"horizontal thrust is is  ",i:(FixedMul(XYThrust , 1.0 - fixedDiv(distdiff,100)))>> 16);
			PlayerX = GetActorX(targetTID);
			PlayerY = GetActorY(targetTID);
			
			ThrustThing(VectorAngle(ActX - PlayerX,ActY - PlayerY)>>8,(FixedMul(XYThrust , 1.0 - fixedDiv(distdiff,100)))>> 16,1,targetTID);
			thrustthingz(targetTID,(FixedMul(ZThrust , 1.0 - fixedDiv(distdiff,100)))>> 16,1,AdditiveForce);
		}
	}
}

}
#endregion
//#endregion

//#region -=- Arc limit -=-

int count;

script "Arc_Limit_Start" (void) CLIENTSIDE
{
count = 0;
}

script "Arc_Limit" (void) CLIENTSIDE
{
count++;
SetResultValue(count>50);
}

script "Arc_ClientSide" (void) CLIENTSIDE
{
	int u = UniqueTID();
	SetActivator(0,AAPTR_TARGET);
	//Log(i:consoleplayernumber(),s:" ",i:playernumber());
	if(consoleplayernumber() != playernumber()){
		SetResultValue(0);
	}
	else
	{SetResultValue(1);}
}

script "Arc_ClientSide2" (int TargTID) CLIENTSIDE
{
	//int u = UniqueTID();
	SetActivator(TargTID);
	//Log(i:consoleplayernumber(),s:" ",i:playernumber(),s:" ",s:GetActorClass(0));
	if(consoleplayernumber() != playernumber()){
		SetResultValue(0);
	}
	else
	{SetResultValue(1);}
}
//#endregion

Script "MSTD_ActorClassifier" (int TID, int CheckType)
{
bool output;
   
switch(CheckType)
	{
	case 0: if ((ClassifyActor(TID) & ACTOR_NONE)){output = true;} break;
	case 1: if ((ClassifyActor(TID) & ACTOR_WORLD)){output = true;} break;
	case 2: if ((ClassifyActor(TID) & ACTOR_PLAYER)){output = true;} break;
	case 3: if ((ClassifyActor(TID) & ACTOR_BOT)){output = true;} break;
	case 4: if ((ClassifyActor(TID) & ACTOR_VOODOODOLL)){output = true;} break;
	case 5: if ((ClassifyActor(TID) & ACTOR_MONSTER)){output = true;} break;
	case 6: if ((ClassifyActor(TID) & ACTOR_ALIVE)){output = true;} break;
	case 7: if ((ClassifyActor(TID) & ACTOR_DEAD)){output = true;} break;
	case 8: if ((ClassifyActor(TID) & ACTOR_MISSILE)){output = true;} break;
	case 9: if ((ClassifyActor(TID) & ACTOR_GENERIC)){output = true;} break;
	}

SetResultValue(output);
}

Script "HitSound" (void)
{
localAmbientSound("misc/metdie",127);
}

script "Spawn_SmallHealth_MSTD" (void)
{
SpawnNewWepFunc("SmallHealth_MSTD");
}

script "Spawn_BigHealth_MSTD" (void)
{
SpawnNewWepFunc("BigHealth_MSTD");
}

//Damage Over Time Script
script "DotDamager" (int damage, int TID)
{
setactivator(0,AAPTR_TARGET);
thing_damage2(TID,damage,"OB_Burner");
}

script "HitKnockBack" (int force)
{
int pusher = ACS_NamedExecuteWithResult("Core_GetTarget", 0);
int Vang = VectorAngle(GetActorX(0) - GetActorX(pusher), GetActorY(0) - GetActorY(pusher)) >> 8;
ThrustThing(Vang, force, 1, 0);
}


function bool OpenGLCvarClient(void)
{
return (getCvar("vid_renderer"));
}

script "MMBN_OpenGLCheck" (void) CLIENTSIDE
{
SetResultValue(OpenGLCvarClient());
}

Script "MassimoDamageRamp" (int MinDam, int MaxDam)
{
int HealthPer = ACS_NamedExecuteWithResult("MSTD_HealthPercent",AAPTR_TARGET);
int Output = ValueMap(HealthPer,100,0,MinDam,MaxDam);
SetResultValue(Output);
}

Script "SniperBusterRamp" (int hitCap, int MinDam, int MaxDam)
{
SetActivatorToTarget(0);
str WepName = STD_WhichWeaponName();
str WepName2 = StrLeft(WepName,StrLen(WepName)-StrLen("Wep"));
log(s:WepName);
log(s:WepName2);
int ItemCount = CheckInventory(StrParam(s:WepName2,s:"_HitCounter"));
if(ItemCount > hitCap){ItemCount = hitCap;}
int Output = ValueMap(ItemCount,0,hitCap,MinDam,MaxDam);
SetResultValue(Output);
}



Script "CheckStatusGuard" (int Pointer, int Input)
{
Int Output;

/*
 * 0 = no status protection
 * 1 = Minor status protection
 * 2 = Major status protection
 *
 */ 


if(Pointer!=0){SetActivator(0,Pointer);}


if(CheckInventory("PoisonMark")
||CheckInventory("BurnMark")
||CheckInventory("FrostbiteMark")
)
{Output = Output | STATUS_MAJOR;}

//if(CheckInventory("ProtectGuard")
//||CheckInventory("DetectGuard")
//||CheckInventory("SubGuard"))
//{Output = Output | STATUS_MAJOR | STATUS_MINOR | STATUS_STATS;}

    //if(CheckInventory("SafeguardPower"))
    //{Output = Output | STATUS_MAJOR | STATUS_MINOR | STATUS_SPECIALTY | STATUS_TAUNT;}

    //if(CheckInventory("MistFlag"))
    //{Output = Output | STATUS_STATS  | STATUS_MINOR | STATUS_TAUNT;}

    //if(CheckInventory("CleanseTag"))
    //{Output = Output | STATUS_STATS;}
SetResultValue(Output & Input);
}